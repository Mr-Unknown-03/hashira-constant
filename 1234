#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

// Convert a single digit character to int value (supports 0-9, a-f)
int digit_to_val(char c) {
    if (c >= '0' && c <= '9') return c - '0';
    else if (c >= 'a' && c <= 'f') return 10 + (c - 'a');
    else if (c >= 'A' && c <= 'F') return 10 + (c - 'A');
    return -1; // invalid digit
}

// Convert string in base 'base' to long long decimal
unsigned long long base_to_dec(const char* str, int base) {
    unsigned long long result = 0;
    while (*str) {
        int val = digit_to_val(*str);
        if (val < 0 || val >= base) {
            printf("Invalid digit '%c' for base %d\n", *str, base);
            exit(1);
        }
        result = result * base + val;
        str++;
    }
    return result;
}

// Perform Lagrange interpolation at x=0 for k points
long long lagrange_at_zero(int k, long long x[], long long y[]) {
    double result = 0.0;
    for (int i = 0; i < k; i++) {
        double term = (double)y[i];
        for (int j = 0; j < k; j++) {
            if (i != j) {
                term *= -x[j];
                term /= (x[i] - x[j]);
            }
        }
        result += term;
    }
    return llround(result);
}

int main() {
    // Hardcoded input from first test case
    int n = 4;
    int k = 3;
    
    // Format: {x, base, value}
    struct {
        int x;
        int base;
        const char* val;
    } points[] = {
        {1, 10, "4"},
        {2, 2, "111"},
        {3, 10, "12"},
        {6, 4, "213"}
    };

    long long xs[4], ys[4];
    for (int i = 0; i < n; i++) {
        xs[i] = points[i].x;
        ys[i] = base_to_dec(points[i].val, points[i].base);
    }

    // Use only first k points (as per problem)
    long long xk[3], yk[3];
    for (int i = 0; i < k; i++) {
        xk[i] = xs[i];
        yk[i] = ys[i];
    }

    long long secret = lagrange_at_zero(k, xk, yk);
    printf("Secret c (Test case 1) = %lld\n", secret);
    return 0;
}


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

int digit_to_val(char c) {
    if (c >= '0' && c <= '9') return c - '0';
    else if (c >= 'a' && c <= 'f') return 10 + (c - 'a');
    else if (c >= 'A' && c <= 'F') return 10 + (c - 'A');
    return -1;
}

unsigned long long base_to_dec(const char* str, int base) {
    unsigned long long result = 0;
    while (*str) {
        int val = digit_to_val(*str);
        if (val < 0 || val >= base) {
            printf("Invalid digit '%c' for base %d\n", *str, base);
            exit(1);
        }
        result = result * base + val;
        str++;
    }
    return result;
}

long long lagrange_at_zero(int k, long long x[], long long y[]) {
    double result = 0.0;
    for (int i = 0; i < k; i++) {
        double term = (double)y[i];
        for (int j = 0; j < k; j++) {
            if (i != j) {
                term *= -x[j];
                term /= (x[i] - x[j]);
            }
        }
        result += term;
    }
    return llround(result);
}

int main() {
    int n = 10;
    int k = 7;

    struct {
        int x;
        int base;
        const char* val;
    } points[] = {
        {1, 7, "420020006424065463"},
        {2, 7, "10511630252064643035"},
        {3, 2, "101010101001100101011100000001000111010010111101100100010"},
        {4, 8, "31261003022226126015"},
        {5, 7, "2564201006101516132035"},
        {6, 15, "a3c97ed550c69484"},
        {7, 13, "134b08c8739552a734"},
        {8, 10, "23600283241050447333"},
        {9, 9, "375870320616068547135"},
        {10, 6, "30140555423010311322515333"}
    };

    long long xs[10], ys[10];
    for (int i = 0; i < n; i++) {
        xs[i] = points[i].x;
        ys[i] = base_to_dec(points[i].val, points[i].base);
    }

    long long xk[7], yk[7];
    for (int i = 0; i < k; i++) {
        xk[i] = xs[i];
        yk[i] = ys[i];
    }

    long long secret = lagrange_at_zero(k, xk, yk);
    printf("Secret c (Test case 2) = %lld\n", secret);

    return 0;
}
