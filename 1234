#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

// Convert a single digit character to int value (supports 0-9, a-f)
int digit_to_val(char c) {
    if (c >= '0' && c <= '9') return c - '0';
    else if (c >= 'a' && c <= 'f') return 10 + (c - 'a');
    else if (c >= 'A' && c <= 'F') return 10 + (c - 'A');
    return -1; // invalid digit
}

// Convert string in base 'base' to long long decimal
unsigned long long base_to_dec(const char* str, int base) {
    unsigned long long result = 0;
    while (*str) {
        int val = digit_to_val(*str);
        if (val < 0 || val >= base) {
            printf("Invalid digit '%c' for base %d\n", *str, base);
            exit(1);
        }
        result = result * base + val;
        str++;
    }
    return result;
}

// Perform Lagrange interpolation at x=0 for k points
long long lagrange_at_zero(int k, long long x[], long long y[]) {
    double result = 0.0;
    for (int i = 0; i < k; i++) {
        double term = (double)y[i];
        for (int j = 0; j < k; j++) {
            if (i != j) {
                term *= -x[j];
                term /= (x[i] - x[j]);
            }
        }
        result += term;
    }
    return llround(result);
}

int main() {
    // Hardcoded input from first test case
    int n = 4;
    int k = 3;
    
    // Format: {x, base, value}
    struct {
        int x;
        int base;
        const char* val;
    } points[] = {
        {1, 10, "4"},
        {2, 2, "111"},
        {3, 10, "12"},
        {6, 4, "213"}
    };

    long long xs[4], ys[4];
    for (int i = 0; i < n; i++) {
        xs[i] = points[i].x;
        ys[i] = base_to_dec(points[i].val, points[i].base);
    }

    // Use only first k points (as per problem)
    long long xk[3], yk[3];
    for (int i = 0; i < k; i++) {
        xk[i] = xs[i];
        yk[i] = ys[i];
    }

    long long secret = lagrange_at_zero(k, xk, yk);
    printf("Secret c (Test case 1) = %lld\n", secret);
    return 0;
}



